<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Spot Calculator (Open-Meteo)</title>
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      max-width: 900px;
      margin: 2rem auto;
      padding: 0 1rem;
      background: #0b1120;
      color: #e5e7eb;
    }
    h1, h2 {
      margin: 0.5rem 0;
    }
    #spot_calculator {
      background: #020617;
      border-radius: 0.75rem;
      padding: 1rem 1.25rem;
      box-shadow: 0 10px 25px rgba(0,0,0,0.4);
      border: 1px solid #1f2937;
      margin-bottom: 1.5rem;
    }
    .row {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
      gap: 0.75rem;
      margin: 0.5rem 0 1rem;
    }
    label {
      font-size: 0.85rem;
      display: block;
      margin-bottom: 0.25rem;
    }
    input, select {
      width: 100%;
      padding: 0.35rem 0.5rem;
      border-radius: 0.5rem;
      border: 1px solid #374151;
      background: #020617;
      color: #e5e7eb;
      font-size: 0.9rem;
      box-sizing: border-box;
    }
    input:focus, select:focus {
      outline: none;
      border-color: #38bdf8;
      box-shadow: 0 0 0 1px #38bdf8;
    }
    table.spot_calc {
      width: 100%;
      border-collapse: collapse;
      margin-top: 0.5rem;
      font-size: 0.9rem;
    }
    table.spot_calc td {
      padding: 0.3rem 0.4rem;
    }
    table.spot_calc tr:nth-child(odd) {
      background: #020617;
    }
    table.spot_calc tr:nth-child(even) {
      background: #020318;
    }
    .btn {
      border: none;
      border-radius: 999px;
      padding: 0.4rem 0.9rem;
      font-size: 0.9rem;
      cursor: pointer;
      font-weight: 600;
    }
    .btn-primary {
      background: linear-gradient(135deg, #22c55e, #0ea5e9);
      color: white;
    }
    .btn-secondary {
      background: #111827;
      color: #e5e7eb;
      border: 1px solid #374151;
    }
    .btn:disabled {
      opacity: 0.5;
      cursor: default;
    }
    #spot_result_in {
      margin-top: 1rem;
      padding-top: 0.75rem;
      border-top: 1px solid #1f2937;
      font-size: 0.95rem;
    }
    #spot_errors_in {
      margin-top: 0.75rem;
      color: #fca5a5;
      font-size: 0.85rem;
    }
    #status {
      font-size: 0.8rem;
      margin-top: 0.3rem;
      color: #9ca3af;
    }
    #status.error {
      color: #fca5a5;
    }
    small {
      color: #9ca3af;
    }
  </style>
</head>
<body>

<h1>Spot Calculator</h1>
<p><small>JavaScript remake of the original PHP calculator, using Open-Meteo winds.</small></p>

<div id="spot_calculator">
  <!-- AIRCRAFT + LOCATION -->
  <div class="row">
    <div>
      <label for="plane">Select Aircraft</label>
      <select id="plane">
        <option value="kingair">King Air</option>
        <option value="twinotter" selected>Twin Otter</option>
        <option value="c182">Cessna-182</option>
      </select>
    </div>
    <div>
      <label for="lat">Latitude (DZ)</label>
      <input id="lat" type="number" step="0.0001" value="42.6981" />
    </div>
    <div>
      <label for="lon">Longitude (DZ)</label>
      <input id="lon" type="number" step="0.0001" value="-87.9580" />
    </div>
  </div>

  <div class="row">
    <div>
      <button id="autoFillBtn" class="btn btn-secondary">Auto-fill winds from Open-Meteo</button>
      <div id="status"></div>
    </div>
    <div>
      <small>
        Uses nearest forecast hour at multiple pressure levels + 10m surface wind.<br>
        You can still edit the numbers by hand.
      </small>
    </div>
  </div>

  <!-- WINDS TABLE -->
  <table class="spot_calc">
    <tbody>
      <tr>
        <td align="right">12000 - Direction (°)</td>
        <td><input type="text" id="d12000" /></td>
        <td align="right">Speed (kt)</td>
        <td><input type="text" id="s12000" /></td>
      </tr>
      <tr>
        <td align="right">9000 - Direction (°)</td>
        <td><input type="text" id="d9000" /></td>
        <td align="right">Speed (kt)</td>
        <td><input type="text" id="s9000" /></td>
      </tr>
      <tr>
        <td align="right">6000 - Direction (°)</td>
        <td><input type="text" id="d6000" /></td>
        <td align="right">Speed (kt)</td>
        <td><input type="text" id="s6000" /></td>
      </tr>
      <tr>
        <td align="right">3000 - Direction (°)</td>
        <td><input type="text" id="d3000" /></td>
        <td align="right">Speed (kt)</td>
        <td><input type="text" id="s3000" /></td>
      </tr>
      <tr>
        <td align="right">Ground - Direction (°)</td>
        <td><input type="text" id="d000" /></td>
        <td align="right">Speed (kt)</td>
        <td><input type="text" id="s000" /></td>
      </tr>
    </tbody>
  </table>

  <div style="text-align: right; margin-top: 0.75rem;">
    <button id="calcBtn" class="btn btn-primary">Get Current Spot</button>
  </div>

  <div id="spot_errors_in"></div>
  <div id="spot_result_in"></div>
</div>

<script>
  // ---- OPEN-METEO AUTO-FILL ----

  const BASE_URL = "https://api.open-meteo.com/v1/forecast";

  // Map FD altitudes to approximate Open-Meteo pressure levels
  // 12000ft -> 600hPa (~4.2 km)
  // 9000ft  -> 700hPa (~3 km)
  // 6000ft  -> 800hPa (~1.9 km)
  // 3000ft  -> 925hPa (~0.8 km)
  // Ground  -> 10m surface wind
  const levelMap = {
    "12000": "600hPa",
    "9000":  "700hPa",
    "6000":  "800hPa",
    "3000":  "925hPa"
  };

  function setStatus(msg, isError = false) {
    const el = document.getElementById("status");
    el.textContent = msg;
    el.classList.toggle("error", !!isError);
  }

  function buildOpenMeteoUrl(lat, lon) {
    const vars = [];
    Object.values(levelMap).forEach(pl => {
      vars.push(`wind_speed_${pl}`);
      vars.push(`wind_direction_${pl}`);
    });
    vars.push("wind_speed_10m");
    vars.push("wind_direction_10m");

    const params = new URLSearchParams({
      latitude: lat,
      longitude: lon,
      hourly: vars.join(","),
      windspeed_unit: "kn",  // knots
      timeformat: "unixtime",
      timezone: "auto",
      forecast_days: "1"
    });

    return `${BASE_URL}?${params.toString()}`;
  }

  function getNearestHourIndex(timeArray) {
    if (!timeArray || !timeArray.length) return 0;
    const now = Math.floor(Date.now() / 1000); // seconds
    let bestIdx = 0;
    let bestDiff = Math.abs(timeArray[0] - now);
    for (let i = 1; i < timeArray.length; i++) {
      const diff = Math.abs(timeArray[i] - now);
      if (diff < bestDiff) {
        bestDiff = diff;
        bestIdx = i;
      }
    }
    return bestIdx;
  }

  async function autoFillFromOpenMeteo() {
    const lat = parseFloat(document.getElementById("lat").value);
    const lon = parseFloat(document.getElementById("lon").value);
    if (Number.isNaN(lat) || Number.isNaN(lon)) {
      setStatus("Please enter valid latitude and longitude.", true);
      return;
    }

    setStatus("Loading winds from Open-Meteo…");
    document.getElementById("autoFillBtn").disabled = true;

    try {
      const url = buildOpenMeteoUrl(lat, lon);
      const res = await fetch(url);
      if (!res.ok) throw new Error("HTTP " + res.status);
      const data = await res.json();

      const times = data.hourly.time;
      const idx = getNearestHourIndex(times);

      // Helper to read a level safely
      function readLevel(plKey) {
        const speedKey = `wind_speed_${plKey}`;
        const dirKey   = `wind_direction_${plKey}`;
        const speeds = data.hourly[speedKey];
        const dirs   = data.hourly[dirKey];
        if (!speeds || !dirs) return { speed: null, dir: null };
        return { speed: speeds[idx], dir: dirs[idx] };
      }

      // 12000 / 9000 / 6000 / 3000
      const l120 = readLevel(levelMap["12000"]);
      const l090 = readLevel(levelMap["9000"]);
      const l060 = readLevel(levelMap["6000"]);
      const l030 = readLevel(levelMap["3000"]);

      // Ground (10m)
      const sfcSpeeds = data.hourly["wind_speed_10m"];
      const sfcDirs   = data.hourly["wind_direction_10m"];
      const ground = (sfcSpeeds && sfcDirs)
        ? { speed: sfcSpeeds[idx], dir: sfcDirs[idx] }
        : { speed: null, dir: null };

      const fmt = v => (v == null ? "" : v.toFixed(0));

      document.getElementById("d12000").value = fmt(l120.dir);
      document.getElementById("s12000").value = fmt(l120.speed);

      document.getElementById("d9000").value  = fmt(l090.dir);
      document.getElementById("s9000").value  = fmt(l090.speed);

      document.getElementById("d6000").value  = fmt(l060.dir);
      document.getElementById("s6000").value  = fmt(l060.speed);

      document.getElementById("d3000").value  = fmt(l030.dir);
      document.getElementById("s3000").value  = fmt(l030.speed);

      document.getElementById("d000").value   = fmt(ground.dir);
      document.getElementById("s000").value   = fmt(ground.speed);

      const d = new Date(times[idx] * 1000);
      setStatus("Winds loaded for: " + d.toLocaleString());
    } catch (err) {
      console.error(err);
      setStatus("Error fetching data from Open-Meteo.", true);
    } finally {
      document.getElementById("autoFillBtn").disabled = false;
    }
  }

  document.getElementById("autoFillBtn").addEventListener("click", autoFillFromOpenMeteo);

  // ---- SPOT MATH (PORTED FROM YOUR PHP) ----

  function degToRad(deg) {
    return deg * Math.PI / 180;
  }

  function calculateSpot() {
    const errEl = document.getElementById("spot_errors_in");
    const resEl = document.getElementById("spot_result_in");
    errEl.innerHTML = "";
    resEl.innerHTML = "";

    // Read and validate inputs
    function num(id, label) {
      const v = parseFloat(document.getElementById(id).value);
      if (Number.isNaN(v)) {
        throw new Error(label + " not valid");
      }
      return v;
    }

    let a12, s12, a9, s9, a6, s6, a3, s3, a0, s0;
    const errors = [];

    function safeRead(fn, id, label) {
      try {
        return fn(id, label);
      } catch (e) {
        errors.push(e.message);
        return null;
      }
    }

    a12 = safeRead(num, "d12000", "Direction 12000");
    s12 = safeRead(num, "s12000", "Wind speed 12000");
    a9  = safeRead(num, "d9000",  "Direction 9000");
    s9  = safeRead(num, "s9000",  "Wind speed 9000");
    a6  = safeRead(num, "d6000",  "Direction 6000");
    s6  = safeRead(num, "s6000",  "Wind speed 6000");
    a3  = safeRead(num, "d3000",  "Direction 3000");
    s3  = safeRead(num, "s3000",  "Wind speed 3000");
    a0  = safeRead(num, "d000",   "Direction 000");
    s0  = safeRead(num, "s000",   "Wind speed 000");

    if (errors.length) {
      errEl.innerHTML = "<br />" + errors.join("<br />");
      return;
    }

    // Normalise directions to 0..360 like PHP did
    function normDir(a) {
      let x = a % 360;
      if (x < 0) x += 360;
      return x;
    }
    a12 = normDir(a12);
    a9  = normDir(a9);
    a6  = normDir(a6);
    a3  = normDir(a3);
    a0  = normDir(a0);

    // Wind components per layer (same as PHP):
    // ff12000x = cos(2*M_PI * (a12/360)) * ((s12*115)/100) * (15/3600);
    // times: 15s, 15s, 15s, 110s, 90s
    function layerComponent(angleDeg, speedKt, seconds) {
      const angleRad = 2 * Math.PI * (angleDeg / 360);
      const scaledSpeed = (speedKt * 115) / 100; // original fudge factor
      const hours = seconds / 3600;
      const x = Math.cos(angleRad) * scaledSpeed * hours;
      const y = Math.sin(angleRad) * scaledSpeed * hours;
      return { x, y };
    }

    const l12 = layerComponent(a12, s12, 15);
    const l9  = layerComponent(a9,  s9,  15);
    const l6  = layerComponent(a6,  s6,  15);
    const l3  = layerComponent(a3,  s3, 110);
    const l0  = layerComponent(a0,  s0,  90);

    const plane = document.getElementById("plane").value;

    let airplanedrift, light2doordelay, jumprunlength, xtotal, ytotal;

    switch (plane) {
      case "kingair":
        airplanedrift    = 0.2;
        light2doordelay  = 0.15;
        jumprunlength    = 1.5;
        xtotal = l12.x + l9.x + l6.x + l3.x + l0.x;
        ytotal = l12.y + l9.y + l6.y + l3.y + l0.y;
        break;
      case "twinotter":
        airplanedrift    = 0.12;
        light2doordelay  = 0.10;
        jumprunlength    = 0.8;
        xtotal = l12.x + l9.x + l6.x + l3.x + l0.x;
        ytotal = l12.y + l9.y + l6.y + l3.y + l0.y;
        break;
      case "c182":
      default:
        airplanedrift    = 0.06;
        light2doordelay  = 0.2;
        jumprunlength    = 0.2;
        // No 12k layer for 182 in original code
        xtotal = l9.x + l6.x + l3.x + l0.x;
        ytotal = l9.y + l6.y + l3.y + l0.y;
        break;
    }

    // Total displacement in NM
    const total = Math.floor(1000 * Math.sqrt(xtotal * xtotal + ytotal * ytotal)) / 1000;

    // Resultant heading q (0..359)
    let q = Math.round((Math.atan2(ytotal, xtotal) * 180) / Math.PI);
    if (q < 0) q = Math.round(((Math.atan2(ytotal, xtotal) + 2 * Math.PI) * 180) / Math.PI);
    else       q = Math.round((Math.atan2(ytotal, xtotal) * 180) / Math.PI);

    // Inversion logic (ported from PHP)
    let outputHtml = "";
    let inverted = false;

    if ((Math.abs(q - a12) > 90) && (Math.abs(q - a12) < 180)) {
      inverted = true;

      const greenInv = -(
        total +
        jumprunlength / 2 +
        airplanedrift +
        light2doordelay
      );
      const invDirRaw = (q < 181) ? q + 180 : q - 180;
      const directionInv = Math.round(invDirRaw / 10) * 10;

      const directionReg = Math.round(q / 10) * 10;
      const greenReg = total - (jumprunlength / 2) - airplanedrift - light2doordelay;

      outputHtml +=
        'The "center" of the spot is<strong> ' +
        total.toFixed(3) +
        " </strong>miles at heading<strong> " +
        q +
        " </strong>degrees<br /><br />" +
        '<em>Caution: Because of the difference in direction in upper winds and total displacement an inverted version is displayed.</em><br /><br />' +
        "<strong>Inverted version:</strong> The Green (go) light should be switched on <strong>" +
        greenInv.toFixed(1) +
        "</strong> miles at heading <strong>" +
        directionInv +
        "</strong> degrees<br /><br />" +
        "<strong>Regular version:</strong> The Green (go) light should be switched on <strong>" +
        greenReg.toFixed(1) +
        "</strong> miles at heading <strong>" +
        directionReg +
        "</strong> degrees";
    } else {
      const green = total - (jumprunlength / 2) - airplanedrift - light2doordelay;
      const direction = Math.round(q / 10) * 10;

      outputHtml +=
        'The "center" of the spot is<strong> ' +
        total.toFixed(3) +
        " </strong>miles at heading<strong> " +
        q +
        " </strong>degrees<br /><br />" +
        "Regular version: The Green (go) light should be switched on <strong>" +
        green.toFixed(1) +
        "</strong> miles at heading <strong>" +
        direction +
        "</strong> degrees";
    }

    resEl.innerHTML = outputHtml;
  }

  document.getElementById("calcBtn").addEventListener("click", calculateSpot);
</script>

</body>
</html>